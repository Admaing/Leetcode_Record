# [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

> 给定一个二叉树的根节点 `root` ，返回它的 **中序** 遍历。
>
>  
>
> **示例 1：**
>
> ![img](2022.1.1~.assets/inorder_1.jpg)
>
> ```
> 输入：root = [1,null,2,3]
> 输出：[1,3,2]
> ```



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        if not root:return []
        res, stack = [],[]
        while root:
            if root.left:
                stack.append(root)
                root = root.left
            else:
                while stack and not root.right:
                    res.append(root.val)
                    root = stack.pop()
                res.append(root.val)
                root = root.right
        return res
```

# [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

> 给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。
>
>  
>
> 示例 1：
>
> ![img](2022.1.1~.assets/uniquebstn3.jpg)
>
> 输入：n = 3
> 输出：5



动态规划 :

以每个节点为头部做相同的操作，动态规划

```python
class Solution:
    def numTrees(self, n: int) -> int:
        dp = [0 for _ in range(n+1)]
        dp[0] = 1
        for i in range(1, n+1):
            for j in range(0,i):
                dp[i] += dp[j] * dp[i-j-1]
        return dp[n]
```



# [剑指 Offer II 044. 二叉树每层的最大值](https://leetcode-cn.com/problems/hPov7L/)

> 给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。
>
>  
>
> 示例1：
>
> 输入: root = [1,3,2,5,3,null,9]
> 输出: [1,3,9]
> 解释:
>           1
>          / \
>         3   2
>        / \   \  
>       5   3   9 

python中正负无穷

```
float("inf"), float("-inf")
```

思路：

访问到当前层时，将节点放入队列当中，将队列中的最大值放入到列表当中，每次访问到下一层时，将队列清空，



```python

import math
class Solution:
    def largestValues(self, root: TreeNode) -> List[int]:
        queue,ret = deque(),[]

        if root:
            queue.append(root)

        while queue:
            
            num = -float('inf')
            

            for i in range(len(queue)):
                q = queue.popleft()
                num = max(num,q.val)
                if q.left:
                    queue.append(q.left)

                if q.right :
                    queue.append(q.right)

            ret.append(num)

        return ret
```



# 28. 实现 strStr()

> 实现 strStr() 函数。
>
> 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。
>
> 输入：haystack = "hello", needle = "ll"
> 输出：2

go

```go
func strStr(haystack, needle string) int {
    n, m := len(haystack), len(needle)
outer:
    for i := 0; i+m <= n; i++ {
        for j := range needle {
            if haystack[i+j] != needle[j] {
                continue outer
            }
        }
        return i
    }
    return -1
}
```

# [剑指 Offer II 045. 二叉树最底层最左边的值](https://leetcode-cn.com/problems/LwUNpT/)



>  给定一个二叉树的 **根节点** `root`，请找出该二叉树的 **最底层 最左边** 节点的值。

> 假设二叉树中至少有一个节点。
>
> ```
> 输入: root = [2,1,3]
> 输出: 1
> ```

思路：按照bfs顺序，记录每行的第一个val	

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def findBottomLeftValue(self, root: TreeNode) -> int:
        queue = deque([root])
        # 记录每行的第一个val
        ret = root.val  
        while queue:
            for i in range(len(queue)):
                q = queue.popleft()
                if i == 0 :
                    ret = q.val
                if q.left :
                    queue.append(q.left)
                if q.right:
                    queue.append(q.right)

        return ret
```

# [剑指 Offer II 046. 二叉树的右侧视图](https://leetcode-cn.com/problems/WNC0Lk/)



> 给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
>
> ```
> 输入: [1,2,3,null,5,null,4]
> 输出: [1,3,4]
> ```



思路：同45题，层序遍历，然后将没个队列的最后一个元素

```python
class Solution:
    def rightSideView(self, root: TreeNode) -> int:
        queue = deque()
        if root:
            queue.append(root)
        # print(queue)
        # 记录每行的第一个val
        ret = []  
        while queue:
            w = len(queue)
            for i in range(w):
                q = queue.popleft()
                if i == (w-1):
                    ret.append(q.val)
                if q.left :
                    queue.append(q.left)
                if q.right:
                    queue.append(q.right)

        return ret
```

# [剑指 Offer II 047. 二叉树剪枝](https://leetcode-cn.com/problems/pOCWxh/)

> 给定一个二叉树 根节点 root ，树的每个节点的值要么是 0，要么是 1。请剪除该二叉树中所有节点的值为 0 的子树。
>
> 节点 node 的子树为 node 本身，以及所有 node 的后代。
>
> 输入: [1,null,0,0,1]
> 输出: [1,null,0,null,1] 
> 解释: 
> 只有红色节点满足条件“所有不包含 1 的子树”。
> 右图为返回的答案。
>



```python
class Solution:
    def pruneTree(self, root):
        if not root:
            return root
        root.left = self.pruneTree(root.left)
        root.right = self.pruneTree(root.right)
        if root.val == 0 and not root.left and not root.right:
            return None
        return root
```

1
