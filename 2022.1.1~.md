# [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

> 给定一个二叉树的根节点 `root` ，返回它的 **中序** 遍历。
>
>  
>
> **示例 1：**
>
> ![img](2022.1.1~.assets/inorder_1.jpg)
>
> ```
> 输入：root = [1,null,2,3]
> 输出：[1,3,2]
> ```



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        if not root:return []
        res, stack = [],[]
        while root:
            if root.left:
                stack.append(root)
                root = root.left
            else:
                while stack and not root.right:
                    res.append(root.val)
                    root = stack.pop()
                res.append(root.val)
                root = root.right
        return res
```

# [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

> 给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。
>
>  
>
> 示例 1：
>
> ![img](2022.1.1~.assets/uniquebstn3.jpg)
>
> 输入：n = 3
> 输出：5



动态规划 :

以每个节点为头部做相同的操作，动态规划

```python
class Solution:
    def numTrees(self, n: int) -> int:
        dp = [0 for _ in range(n+1)]
        dp[0] = 1
        for i in range(1, n+1):
            for j in range(0,i):
                dp[i] += dp[j] * dp[i-j-1]
        return dp[n]
```



# [剑指 Offer II 044. 二叉树每层的最大值](https://leetcode-cn.com/problems/hPov7L/)

> 给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。
>
>  
>
> 示例1：
>
> 输入: root = [1,3,2,5,3,null,9]
> 输出: [1,3,9]
> 解释:
>           1
>          / \
>         3   2
>        / \   \  
>       5   3   9 

python中正负无穷

```
float("inf"), float("-inf")
```

思路：

访问到当前层时，将节点放入队列当中，将队列中的最大值放入到列表当中，每次访问到下一层时，将队列清空，



```python

import math
class Solution:
    def largestValues(self, root: TreeNode) -> List[int]:
        queue,ret = deque(),[]

        if root:
            queue.append(root)

        while queue:
            
            num = -float('inf')
            

            for i in range(len(queue)):
                q = queue.popleft()
                num = max(num,q.val)
                if q.left:
                    queue.append(q.left)

                if q.right :
                    queue.append(q.right)

            ret.append(num)

        return ret
```



# 28. 实现 strStr()

> 实现 strStr() 函数。
>
> 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。
>
> 输入：haystack = "hello", needle = "ll"
> 输出：2

go

```go
func strStr(haystack, needle string) int {
    n, m := len(haystack), len(needle)
outer:
    for i := 0; i+m <= n; i++ {
        for j := range needle {
            if haystack[i+j] != needle[j] {
                continue outer
            }
        }
        return i
    }
    return -1
}
```

